import { isReactive, isReadonly, unref, reactive, computed, isRef, watch, ref, nextTick, getCurrentInstance, isVue3, onBeforeMount, onBeforeUnmount, inject, provide } from 'vue-demi';

function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function (obj) {
      return typeof obj;
    };
  } else {
    _typeof = function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
}

function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

  return arr2;
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function unwrapObj(obj) {
  var ignoreKeys = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  return Object.keys(obj).reduce(function (o, k) {
    if (ignoreKeys.includes(k)) return o;
    o[k] = unref(obj[k]);
    return o;
  }, {});
}
function isFunction(val) {
  return typeof val === 'function';
}
function isProxy(value) {
  return isReactive(value) || isReadonly(value);
}

function _call(body, then, direct) {
  if (direct) {
    return then ? then(body()) : body();
  }

  try {
    var result = Promise.resolve(body());
    return then ? result.then(then) : result;
  } catch (e) {
    return Promise.reject(e);
  }
}

var ROOT_PATH = '__root';
/**
 * @typedef {import('vue-demi').ComponentPublicInstance} VueInstance
 */

/**
 * @typedef {import('vue-demi').ComputedRef} ComputedRef
 */

/**
 * @typedef {import('vue-demi').WatchStopHandle} WatchStopHandle
 */

/**
 * @typedef NormalizedValidator
 * @property {Validator} $validator
 * @property {String | Ref<String> | function(*): string} [$message]
 * @property {Object | Ref<Object>} [$params]
 * @property {Object | Ref<Object>} [$async]
 * @property {Ref<*>[]} [$watchTargets]
 */

/**
 * Response form a raw Validator function.
 * Should return a Boolean or an object with $invalid property.
 * @typedef {Boolean | { $valid: Boolean }} ValidatorResponse
 */

/**
 * Raw validator function, before being normalized
 * Can return a Promise or a {@see ValidatorResponse}
 * @typedef {function(*): ((Promise<ValidatorResponse> | ValidatorResponse))} Validator
 */

/**
 * Sorts the validators for a state tree branch
 * @param {Object<NormalizedValidator|Function>} validationsRaw
 * @return {{ rules: Object<NormalizedValidator>, nestedValidators: Object, config: GlobalConfig }}
 */

function _async(f) {
  return function () {
    for (var args = [], i = 0; i < arguments.length; i++) {
      args[i] = arguments[i];
    }

    try {
      return Promise.resolve(f.apply(this, args));
    } catch (e) {
      return Promise.reject(e);
    }
  };
}
/**
 * Calls a validation rule by unwrapping its value first from a ref.
 * @param {Validator} rule
 * @param {Ref} value
 * @param {VueInstance} instance
 * @return {Promise<ValidatorResponse> | ValidatorResponse}
 */


function sortValidations() {
  var validationsRaw = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var validations = unref(validationsRaw);
  var validationKeys = Object.keys(validations);
  var rules = {};
  var nestedValidators = {};
  var config = {};
  validationKeys.forEach(function (key) {
    var v = validations[key];

    switch (true) {
      // If it is already normalized, use it
      case isFunction(v.$validator):
        rules[key] = v;
        break;
      // If it is just a function, normalize it first
      // into { $validator: <Fun> }

      case isFunction(v):
        rules[key] = {
          $validator: v
        };
        break;
      // Catch $-prefixed properties as config

      case key.startsWith('$'):
        config[key] = v;
        break;
      // If it doesnâ€™t match any of the above,
      // treat as nestedValidators state property

      default:
        nestedValidators[key] = v;
    }
  });
  return {
    rules: rules,
    nestedValidators: nestedValidators,
    config: config
  };
}

function callRule(rule, value, instance) {
  var v = unref(value);
  return rule.call(instance, v, instance);
}
/**
 * Normalizes the validator result
 * Allows passing a boolean of an object like `{ $valid: Boolean }`
 * @param {ValidatorResponse} result - Validator result
 * @return {boolean}
 */


function normalizeValidatorResponse(result) {
  return result.$valid !== undefined ? !result.$valid : !result;
}
/**
 * Returns the result of an async validator.
 * @param {Validator} rule
 * @param {Ref<*>} model
 * @param {Ref<Boolean>} $pending
 * @param {Ref<Boolean>} $dirty
 * @param {GlobalConfig} config
 * @param {boolean} config.$lazy
 * @param {Ref<*>} $response
 * @param {VueInstance} instance
 * @param {Ref<*>[]} watchTargets
 * @return {{ $invalid: Ref<Boolean>, $unwatch: WatchStopHandle }}
 */


function createAsyncResult(rule, model, $pending, $dirty, _ref, $response, instance) {
  var $lazy = _ref.$lazy;
  var watchTargets = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : [];
  var $invalid = ref(!!$dirty.value);
  var $pendingCounter = ref(0);
  $pending.value = false;
  var $unwatch = watch([model, $dirty].concat(watchTargets), function () {
    if ($lazy && !$dirty.value) return false;
    var ruleResult; // make sure we dont break if a validator throws

    try {
      ruleResult = callRule(rule, model, instance);
    } catch (err) {
      // convert to a promise, so we can handle it async
      ruleResult = Promise.reject(err);
    }

    $pendingCounter.value++;
    $pending.value = !!$pendingCounter.value;
    $invalid.value = true;
    Promise.resolve(ruleResult).then(function (data) {
      $pendingCounter.value--;
      $pending.value = !!$pendingCounter.value;
      $response.value = data;
      $invalid.value = normalizeValidatorResponse(data);
    })["catch"](function (error) {
      $pendingCounter.value--;
      $pending.value = !!$pendingCounter.value;
      $response.value = error;
      $invalid.value = true;
    });
  }, {
    immediate: true,
    deep: _typeof(model) === 'object'
  });
  return {
    $invalid: $invalid,
    $unwatch: $unwatch
  };
}
/**
 * Returns the result of a sync validator
 * @param {Validator} rule
 * @param {Ref<*>} model
 * @param {Ref<Boolean>} $dirty
 * @param {GlobalConfig} config
 * @param {Boolean} config.$lazy
 * @param {Ref<*>} $response
 * @param {VueInstance} instance
 * @return {{$unwatch: (function(): {}), $invalid: ComputedRef<boolean>}}
 */


function createSyncResult(rule, model, $dirty, _ref2, $response, instance) {
  var $lazy = _ref2.$lazy;

  var $unwatch = function $unwatch() {
    return {};
  };

  var $invalid = computed(function () {
    if ($lazy && !$dirty.value) return false;

    try {
      var result = callRule(rule, model, instance);
      $response.value = result;
      return normalizeValidatorResponse(result);
    } catch (err) {
      $response.value = err;
    }

    return true;
  });
  return {
    $unwatch: $unwatch,
    $invalid: $invalid
  };
}
/**
 * Returns the validation result.
 * Detects async and sync validators.
 * @param {NormalizedValidator} rule
 * @param {Ref<*>} model
 * @param {Ref<boolean>} $dirty
 * @param {GlobalConfig} config - Vuelidate config
 * @param {VueInstance} instance - component instance
 * @param {string} validatorName - name of the current validator
 * @param {string} propertyKey - the current property we are validating
 * @param {string} propertyPath - the deep path to the validated property
 * @return {{ $params: *, $message: Ref<String>, $pending: Ref<Boolean>, $invalid: Ref<Boolean>, $response: Ref<*>, $unwatch: WatchStopHandle }}
 */


function createValidatorResult(rule, model, $dirty, config, instance, validatorName, propertyKey, propertyPath) {
  var $pending = ref(false);
  var $params = rule.$params || {};
  var $response = ref(null);
  var $invalid;
  var $unwatch;

  if (rule.$async) {
    var _createAsyncResult = createAsyncResult(rule.$validator, model, $pending, $dirty, config, $response, instance, rule.$watchTargets);

    $invalid = _createAsyncResult.$invalid;
    $unwatch = _createAsyncResult.$unwatch;
  } else {
    var _createSyncResult = createSyncResult(rule.$validator, model, $dirty, config, $response, instance);

    $invalid = _createSyncResult.$invalid;
    $unwatch = _createSyncResult.$unwatch;
  }

  var message = rule.$message;
  var $message = isFunction(message) ? computed(function () {
    return message(unwrapObj({
      $pending: $pending,
      $invalid: $invalid,
      $params: unwrapObj($params),
      // $params can hold refs, so we unwrap them for easy access
      $model: model,
      $response: $response,
      $validator: validatorName,
      $propertyPath: propertyPath,
      $property: propertyKey
    }));
  }) : message || '';
  return {
    $message: $message,
    $params: $params,
    $pending: $pending,
    $invalid: $invalid,
    $response: $response,
    $unwatch: $unwatch
  };
}
/**
 * @typedef ErrorObject
 * @property {Ref<String>} $message - Reactive error message
 * @property {Ref<Object>} $params - Params passed from withParams
 * @property {Ref<Boolean>} $pending - If validation is pending
 * @property {String} $property - State key
 * @property {String} $propertyPath - Dot notation path to state
 * @property {String} $validator - Validator name
 * @property {String} $uid - Unique identifier
 */

/**
 * @typedef ValidationResult
 * @property {Ref<Boolean>} $pending
 * @property {Ref<Boolean>} $dirty
 * @property {Ref<Boolean>} $invalid
 * @property {Ref<Boolean>} $error
 * @property {Ref<String>} $path
 * @property {Function} $touch
 * @property {Function} $reset
 * @property {ComputedRef<ErrorObject[]>} $errors
 * @property {ComputedRef<ErrorObject[]>} $silentErrors
 */

/**
 * Creates the main Validation Results object for a state tree
 * Walks the tree's top level branches
 * @param {Object<NormalizedValidator>} rules - Rules for the current state tree
 * @param {Object} model - Current state value
 * @param {String} key - Key for the current state tree
 * @param {ResultsStorage} [resultsCache] - A cache map of all the validators
 * @param {String} [path] - the current property path
 * @param {GlobalConfig} [config] - the config object
 * @param {VueInstance} instance
 * @param {ComputedRef<Object>} externalResults
 * @return {ValidationResult | {}}
 */


function createValidationResults(rules, model, key, resultsCache, path, config, instance, externalResults) {
  // collect the property keys
  var ruleKeys = Object.keys(rules);
  var cachedResult = resultsCache.get(path, rules);
  var $dirty = ref(false);

  if (cachedResult) {
    // if the rules are the same as before, use the cached results
    if (!cachedResult.$partial) return cachedResult; // remove old watchers

    cachedResult.$unwatch(); // use the `$dirty.value`, so we dont save references by accident

    $dirty.value = cachedResult.$dirty.value;
  }

  var result = {
    // restore $dirty from cache
    $dirty: $dirty,
    $path: path,
    $touch: function $touch() {
      if (!$dirty.value) $dirty.value = true;
    },
    $reset: function $reset() {
      if ($dirty.value) $dirty.value = false;
    }
  };
  /**
   * If there are no validation rules, it is most likely
   * a top level state, aka root
   */

  if (!ruleKeys.length) {
    // if there are cached results, we should overwrite them with the new ones
    cachedResult && resultsCache.set(path, rules, result);
    return result;
  }

  ruleKeys.forEach(function (ruleKey) {
    result[ruleKey] = createValidatorResult(rules[ruleKey], model, result.$dirty, config, instance, ruleKey, key, path);
  });
  result.$externalResults = computed(function () {
    if (!externalResults.value) return [];
    return [].concat(externalResults.value).map(function (stringError, index) {
      return {
        $propertyPath: path,
        $property: key,
        $validator: '$externalResults',
        $uid: "".concat(path, "-").concat(index),
        $message: stringError,
        $params: {},
        $response: null,
        $pending: false
      };
    });
  });
  result.$invalid = computed(function () {
    return !!result.$externalResults.value.length || ruleKeys.some(function (ruleKey) {
      return unref(result[ruleKey].$invalid);
    });
  });
  result.$pending = computed(function () {
    return ruleKeys.some(function (ruleKey) {
      return unref(result[ruleKey].$pending);
    });
  });
  result.$error = computed(function () {
    return result.$invalid.value && result.$dirty.value;
  });
  result.$silentErrors = computed(function () {
    return ruleKeys.filter(function (ruleKey) {
      return unref(result[ruleKey].$invalid);
    }).map(function (ruleKey) {
      var res = result[ruleKey];
      return reactive({
        $propertyPath: path,
        $property: key,
        $validator: ruleKey,
        $uid: "".concat(path, "-").concat(ruleKey),
        $message: res.$message,
        $params: res.$params,
        $response: res.$response,
        $pending: res.$pending
      });
    }).concat(result.$externalResults.value);
  });
  result.$errors = computed(function () {
    return result.$dirty.value ? result.$silentErrors.value : [];
  });

  result.$unwatch = function () {
    return ruleKeys.forEach(function (ruleKey) {
      result[ruleKey].$unwatch();
    });
  };

  resultsCache.set(path, rules, result);
  return result;
}
/**
 * Collects the validation results of all nested state properties
 * @param {Object<NormalizedValidator|Function>} validations - The validation
 * @param {Object} nestedState - Current state
 * @param {String} path - Path to current property
 * @param {ResultsStorage} resultsCache - Validations cache map
 * @param {GlobalConfig} config - The config object
 * @param {VueInstance} instance - The current Vue instance
 * @param {ComputedRef<object>} nestedExternalResults - The external results for this nested collection
 * @return {{}}
 */


function collectNestedValidationResults(validations, nestedState, path, resultsCache, config, instance, nestedExternalResults) {
  var nestedValidationKeys = Object.keys(validations); // if we have no state, return empty object

  if (!nestedValidationKeys.length) return {};
  return nestedValidationKeys.reduce(function (results, nestedKey) {
    // build validation results for nested state
    results[nestedKey] = setValidations({
      validations: validations[nestedKey],
      state: nestedState,
      key: nestedKey,
      parentKey: path,
      resultsCache: resultsCache,
      globalConfig: config,
      instance: instance,
      externalResults: nestedExternalResults
    });
    return results;
  }, {});
}
/**
 * Generates the Meta fields from the results
 * @param {ValidationResult|{}} results
 * @param {Object.<string, ValidationResult>[]} nestedResults
 * @param {Object.<string, ValidationResult>[]} childResults
 * @return {{$anyDirty: Ref<Boolean>, $error: Ref<Boolean>, $invalid: Ref<Boolean>, $errors: Ref<ErrorObject[]>, $dirty: Ref<Boolean>, $touch: Function, $reset: Function }}
 */


function createMetaFields(results, nestedResults, childResults) {
  var allResults = computed(function () {
    return [nestedResults, childResults].filter(function (res) {
      return res;
    }).reduce(function (allRes, res) {
      return allRes.concat(Object.values(unref(res)));
    }, []);
  }); // returns `$dirty` as true, if all children are dirty

  var $dirty = computed({
    get: function get() {
      return results.$dirty.value || (allResults.value.length ? allResults.value.every(function (r) {
        return r.$dirty;
      }) : false);
    },
    set: function set(v) {
      results.$dirty.value = v;
    }
  });
  var $silentErrors = computed(function () {
    // current state level errors, fallback to empty array if root
    var modelErrors = unref(results.$silentErrors) || []; // collect all nested and child $silentErrors

    var nestedErrors = allResults.value.filter(function (result) {
      return (unref(result).$silentErrors || []).length;
    }).reduce(function (errors, result) {
      return errors.concat.apply(errors, _toConsumableArray(result.$silentErrors));
    }, []); // merge the $silentErrors

    return modelErrors.concat(nestedErrors);
  });
  var $errors = computed(function () {
    // current state level errors, fallback to empty array if root
    var modelErrors = unref(results.$errors) || []; // collect all nested and child $errors

    var nestedErrors = allResults.value.filter(function (result) {
      return (unref(result).$errors || []).length;
    }).reduce(function (errors, result) {
      return errors.concat.apply(errors, _toConsumableArray(result.$errors));
    }, []); // merge the $errors

    return modelErrors.concat(nestedErrors);
  });
  var $invalid = computed(function () {
    return (// if any of the nested values is invalid
      allResults.value.some(function (r) {
        return r.$invalid;
      }) || // or if the current state is invalid
      unref(results.$invalid) || // fallback to false if is root
      false
    );
  });
  var $pending = computed(function () {
    return (// if any of the nested values is pending
      allResults.value.some(function (r) {
        return unref(r.$pending);
      }) || // if any of the current state validators is pending
      unref(results.$pending) || // fallback to false if is root
      false
    );
  });
  var $anyDirty = computed(function () {
    return allResults.value.some(function (r) {
      return r.$dirty;
    }) || allResults.value.some(function (r) {
      return r.$anyDirty;
    }) || $dirty.value;
  });
  var $error = computed(function () {
    return $invalid.value && $dirty.value || false;
  });

  var $touch = function $touch() {
    // call the root $touch
    results.$touch(); // call all nested level $touch

    allResults.value.forEach(function (result) {
      result.$touch();
    });
  };

  var $reset = function $reset() {
    // reset the root $dirty state
    results.$reset(); // reset all the children $dirty states

    allResults.value.forEach(function (result) {
      result.$reset();
    });
  }; // Ensure that if all child and nested results are $dirty, this also becomes $dirty


  if (allResults.value.length && allResults.value.every(function (nr) {
    return nr.$dirty;
  })) $touch();
  return {
    $dirty: $dirty,
    $errors: $errors,
    $invalid: $invalid,
    $anyDirty: $anyDirty,
    $error: $error,
    $pending: $pending,
    $touch: $touch,
    $reset: $reset,
    $silentErrors: $silentErrors
  };
}
/**
 * @typedef VuelidateState
 * @property {WritableComputedRef<any>} $model
 * @property {ComputedRef<Boolean>} $dirty
 * @property {ComputedRef<Boolean>} $error
 * @property {ComputedRef<ErrorObject[]>} $errors
 * @property {ComputedRef<Boolean>} $invalid
 * @property {ComputedRef<Boolean>} $anyDirty
 * @property {ComputedRef<Boolean>} $pending
 * @property {Function} $touch
 * @property {Function} $reset
 * @property {String} $path
 * @property {ComputedRef<ErrorObject[]>} $silentErrors
 * @property {Function} [$validate]
 * @property {Function} [$getResultsForChild]
 * @property {Object.<string, VuelidateState>}
 */

/**
 * Main Vuelidate bootstrap function.
 * Used both for Composition API in `setup` and for Global App usage.
 * Used to collect validation state, when walking recursively down the state tree
 * @param {Object} params
 * @param {Object<NormalizedValidator|Function>} params.validations
 * @param {Object} params.state
 * @param {String} [params.key] - Current state property key. Used when being called on nested items
 * @param {String} [params.parentKey] - Parent state property key. Used when being called recursively
 * @param {Object<ValidationResult>} [params.childResults] - Used to collect child results.
 * @param {ResultsStorage} params.resultsCache - The cached validation results
 * @param {VueInstance} params.instance - The current Vue instance
 * @param {GlobalConfig} params.globalConfig - The validation config, passed to this setValidations instance.
 * @param {Reactive<object> | Ref<Object>} params.externalResults - External validation results
 * @return {UnwrapNestedRefs<VuelidateState>}
 */


function setValidations(_ref3) {
  var validations = _ref3.validations,
      state = _ref3.state,
      key = _ref3.key,
      parentKey = _ref3.parentKey,
      childResults = _ref3.childResults,
      resultsCache = _ref3.resultsCache,
      _ref3$globalConfig = _ref3.globalConfig,
      globalConfig = _ref3$globalConfig === void 0 ? {} : _ref3$globalConfig,
      instance = _ref3.instance,
      externalResults = _ref3.externalResults;
  var path = parentKey ? "".concat(parentKey, ".").concat(key) : key; // Sort out the validation object into:
  // â€“ rules = validators for current state tree fragment
  // â€” nestedValidators = nested state fragments keys that might contain more validators
  // â€“ config = configuration properties that affect this state fragment

  var _sortValidations = sortValidations(validations),
      rules = _sortValidations.rules,
      nestedValidators = _sortValidations.nestedValidators,
      config = _sortValidations.config;

  var mergedConfig = Object.assign({}, globalConfig, config); // create protected state for cases when the state branch does not exist yet.
  // This protects when using the OptionsAPI as the data is bound after the setup method

  var nestedState = key ? computed(function () {
    var s = unref(state);
    return s ? unref(s[key]) : undefined;
  }) : state; // cache the external results, so we can revert back to them

  var cachedExternalResults = Object.assign({}, unref(externalResults) || {});
  var nestedExternalResults = computed(function () {
    var results = unref(externalResults);
    if (!key) return results;
    return results ? unref(results[key]) : undefined;
  }); // Use rules for the current state fragment and validate it

  var results = createValidationResults(rules, nestedState, key, resultsCache, path, mergedConfig, instance, nestedExternalResults); // Use nested keys to repeat the process
  // *WARN*: This is recursive

  var nestedResults = collectNestedValidationResults(nestedValidators, nestedState, path, resultsCache, mergedConfig, instance, nestedExternalResults); // Collect and merge this level validation results
  // with all nested validation results

  var _createMetaFields = createMetaFields(results, nestedResults, childResults),
      $dirty = _createMetaFields.$dirty,
      $errors = _createMetaFields.$errors,
      $invalid = _createMetaFields.$invalid,
      $anyDirty = _createMetaFields.$anyDirty,
      $error = _createMetaFields.$error,
      $pending = _createMetaFields.$pending,
      $touch = _createMetaFields.$touch,
      $reset = _createMetaFields.$reset,
      $silentErrors = _createMetaFields.$silentErrors;
  /**
   * If we have no `key`, this is the top level state
   * We dont need `$model` there.
   */


  var $model = key ? computed({
    get: function get() {
      return unref(nestedState);
    },
    set: function set(val) {
      $dirty.value = true;
      var s = unref(state);

      if (isRef(s[key])) {
        s[key].value = val;
      } else {
        s[key] = val;
      }
    }
  }) : null;

  if (key && mergedConfig.$autoDirty) {
    var $unwatch = watch(nestedState, function () {
      var autoDirtyPath = "_".concat(path, "_$watcher_");
      var cachedAutoDirty = resultsCache.get(autoDirtyPath, {});
      if (!$dirty.value) $touch();
      if (cachedAutoDirty) cachedAutoDirty.$unwatch();
      resultsCache.set(autoDirtyPath, {}, {
        $unwatch: $unwatch
      });
    }, {
      flush: 'sync'
    });
  }
  /**
   * Executes the validators and returns the result.
   * @return {Promise<boolean>}
   */


  function $validate() {
    return new Promise(_async(function (resolve) {
      if (!$dirty.value) $touch(); // await the watchers

      return _call(nextTick, function () {
        // return whether it is valid or not
        if (!$pending.value) return resolve(!$invalid.value);
        var unwatch = watch($pending, function () {
          resolve(!$invalid.value);
          unwatch();
        });
      });
    }));
  }
  /**
   * Returns a child component's results, based on registration name
   * @param {string} key
   * @return {VuelidateState}
   */


  function $getResultsForChild(key) {
    return (childResults.value || {})[key];
  }

  function $clearExternalResults() {
    if (isRef(externalResults)) {
      externalResults.value = cachedExternalResults;
    } else {
      // if the external results state was empty, we need to delete every property, one by one
      if (Object.keys(cachedExternalResults).length === 0) {
        Object.keys(externalResults).forEach(function (k) {
          delete externalResults[k];
        });
      } else {
        // state was not empty, so we just assign it back into the current state
        Object.assign(externalResults, cachedExternalResults);
      }
    }
  }

  return reactive(Object.assign({}, results, {
    // NOTE: The order here is very important, since we want to override
    // some of the *results* meta fields with the collective version of it
    // that includes the results of nested state validation results
    $model: $model,
    $dirty: $dirty,
    $error: $error,
    $errors: $errors,
    $invalid: $invalid,
    $anyDirty: $anyDirty,
    $pending: $pending,
    $touch: $touch,
    $reset: $reset,
    $path: path || ROOT_PATH,
    $silentErrors: $silentErrors
  }, childResults && {
    $getResultsForChild: $getResultsForChild,
    $validate: $validate,
    $clearExternalResults: $clearExternalResults
  }, nestedResults));
}

var ResultsStorage = /*#__PURE__*/function () {
  function ResultsStorage() {
    _classCallCheck(this, ResultsStorage);

    this.storage = new Map();
  }
  /**
   * Stores a validation result, and its rules by its path
   * @param {String} path
   * @param {Object<NormalizedValidator>} rules
   * @param {ValidationResult} result
   */


  _createClass(ResultsStorage, [{
    key: "set",
    value: function set(path, rules, result) {
      this.storage.set(path, {
        rules: rules,
        result: result
      });
    }
    /**
     * Check if the stored `results` for the provided `path` have the same `rules` compared to 'storedRules'
     * @param {String} path
     * @param {Object<NormalizedValidator>} rules
     * @param {Object<NormalizedValidator>} storedRules
     * @return {Boolean}
     */

  }, {
    key: "checkRulesValidity",
    value: function checkRulesValidity(path, rules, storedRules) {
      var storedRulesKeys = Object.keys(storedRules);
      var newRulesKeys = Object.keys(rules);
      if (newRulesKeys.length !== storedRulesKeys.length) return false;
      var hasAllValidators = newRulesKeys.every(function (ruleKey) {
        return storedRulesKeys.includes(ruleKey);
      });
      if (!hasAllValidators) return false;
      return newRulesKeys.every(function (ruleKey) {
        if (!rules[ruleKey].$params) return true;
        return Object.keys(rules[ruleKey].$params).every(function (paramKey) {
          // make sure to unwrap before comparing
          return unref(storedRules[ruleKey].$params[paramKey]) === unref(rules[ruleKey].$params[paramKey]);
        });
      });
    }
    /**
     * Returns the matched result if catche is valid
     * @param {String} path
     * @param {Object<NormalizedValidator>} rules
     * @return {{$partial: boolean, $dirty: Ref<boolean>}|undefined|ValidationResult}
     */

  }, {
    key: "get",
    value: function get(path, rules) {
      var storedRuleResultPair = this.storage.get(path);
      if (!storedRuleResultPair) return undefined;
      var storedRules = storedRuleResultPair.rules,
          result = storedRuleResultPair.result;
      var isValidCache = this.checkRulesValidity(path, rules, storedRules);
      var $unwatch = result.$unwatch ? result.$unwatch : function () {
        return {};
      };
      if (!isValidCache) return {
        $dirty: result.$dirty,
        $partial: true,
        $unwatch: $unwatch
      };
      return result;
    }
  }]);

  return ResultsStorage;
}();

var VuelidateInjectChildResults = Symbol('vuelidate#injectChiildResults');
var VuelidateRemoveChildResults = Symbol('vuelidate#removeChiildResults');
var CollectFlag = {
  COLLECT_ALL: true,
  COLLECT_NONE: false
};
/**
 * Create helpers to collect validation state from child components
 * @param {Object} params
 * @param {String | Number} params.$scope - Parent component scope
 * @return {{sendValidationResultsToParent: function, childResults: ComputedRef<Object>, removeValidationResultsFromParent: function}}
 */

function nestedValidations(_ref) {
  var $scope = _ref.$scope;
  var childResultsRaw = {};
  var childResultsKeys = ref([]);
  var childResults = computed(function () {
    return childResultsKeys.value.reduce(function (results, key) {
      results[key] = unref(childResultsRaw[key]);
      return results;
    }, {});
  });
  /**
   * Allows children to send validation data up to their parent.
   * @param {Object} results - the results
   * @param {Object} args
   * @param {String} args.$registerAs - the $registeredAs key
   * @param {String | Number} args.$scope - the $scope key
   */

  function injectChildResultsIntoParent(results, _ref2) {
    var key = _ref2.$registerAs,
        childScope = _ref2.$scope,
        $stopPropagation = _ref2.$stopPropagation;
    if ($stopPropagation || $scope === CollectFlag.COLLECT_NONE || childScope === CollectFlag.COLLECT_NONE || $scope !== CollectFlag.COLLECT_ALL && $scope !== childScope) return;
    childResultsRaw[key] = results;
    childResultsKeys.value.push(key);
  }
  /**
   * Allows children to remove the validation data from their parent, before getting destroyed.
   * @param {String} key - the registeredAs key
   */


  function removeChildResultsFromParent(key) {
    // remove the key
    childResultsKeys.value = childResultsKeys.value.filter(function (childKey) {
      return childKey !== key;
    }); // remove the stored data for the key

    delete childResultsRaw[key];
  } // inject the `injectChildResultsIntoParent` method, into the current scope


  var sendValidationResultsToParent = inject(VuelidateInjectChildResults, function () {}); // provide to all of its children the send results to parent function

  provide(VuelidateInjectChildResults, injectChildResultsIntoParent);
  var removeValidationResultsFromParent = inject(VuelidateRemoveChildResults, function () {}); // provide to all of its children the remove results  function

  provide(VuelidateRemoveChildResults, removeChildResultsFromParent);
  return {
    childResults: childResults,
    sendValidationResultsToParent: sendValidationResultsToParent,
    removeValidationResultsFromParent: removeValidationResultsFromParent
  };
}
/**
 * @typedef GlobalConfig
 * @property {String} [$registerAs] - Config Object
 * @property {String | Number | Symbol} [$scope] - A scope to limit child component registration
 * @property {Boolean} [$stopPropagation] - Tells a Vue component to stop sending its results up to the parent
 * @property {Ref<Object>} [$externalResults] - External error messages, like from server validation.
 */

/**
 * Composition API compatible Vuelidate
 * Use inside the `setup` lifecycle hook
 * @param {Object | GlobalConfig} [validations] - Validations Object or the globalConfig.
 * @param {Object} [state] - State object - required if `validations` is a validation object.
 * @param {GlobalConfig} [globalConfig] - Config Object
 * @return {UnwrapRef<*>}
 */


function useVuelidate(validations, state) {
  var globalConfig = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

  // if we pass only one argument, its most probably the globalConfig.
  // This use case is so parents can just collect results of child forms.
  if (arguments.length === 1) {
    globalConfig = validations;
    validations = undefined;
    state = undefined;
  }

  var _globalConfig = globalConfig,
      $registerAs = _globalConfig.$registerAs,
      _globalConfig$$scope = _globalConfig.$scope,
      $scope = _globalConfig$$scope === void 0 ? CollectFlag.COLLECT_ALL : _globalConfig$$scope,
      $stopPropagation = _globalConfig.$stopPropagation,
      $externalResults = _globalConfig.$externalResults;
  var instance = getCurrentInstance();
  var componentOptions = instance ? isVue3 ? instance.type : instance.proxy.$options : {}; // if there is no registration name, add one.

  if (!$registerAs && instance) {
    // NOTE:
    // ._uid // Vue 2.x Composition-API plugin
    // .uid // Vue 3.0
    var uid = instance.uid || instance._uid;
    $registerAs = "_vuelidate_".concat(uid);
  }

  var validationResults = ref({});
  var resultsCache = new ResultsStorage();

  var _ref3 = instance ? nestedValidations({
    $scope: $scope
  }) : {
    childResults: ref({})
  },
      childResults = _ref3.childResults,
      sendValidationResultsToParent = _ref3.sendValidationResultsToParent,
      removeValidationResultsFromParent = _ref3.removeValidationResultsFromParent; // Options API


  if (!validations && componentOptions.validations) {
    var rules = componentOptions.validations;
    state = ref({});
    onBeforeMount(function () {
      // Delay binding state to validations defined with the Options API until mounting, when the data
      // has been attached to the component instance. From that point on it will be reactive.
      state.value = instance.proxy; // helper proxy for instance property access. It makes every reference
      // reactive for the validation function

      function ComputedProxyFactory(target) {
        return new Proxy(target, {
          get: function get(target, prop, receiver) {
            return _typeof(target[prop]) === 'object' ? ComputedProxyFactory(target[prop]) : computed(function () {
              return target[prop];
            });
          }
        });
      }

      watch(function () {
        return isFunction(rules) ? rules.call(state.value, new ComputedProxyFactory(state.value)) : rules;
      }, function (validations) {
        validationResults.value = setValidations({
          validations: validations,
          state: state,
          childResults: childResults,
          resultsCache: resultsCache,
          globalConfig: globalConfig,
          instance: instance.proxy,
          externalResults: instance.proxy.vuelidateExternalResults
        });
      }, {
        immediate: true
      });
    });
    globalConfig = componentOptions.validationsConfig || {};
  } else {
    var validationsWatchTarget = isRef(validations) || isProxy(validations) ? validations // wrap plain objects in a reactive, so we can track changes if they have computed in them.
    : reactive(validations || {});
    watch(validationsWatchTarget, function (newValidationRules) {
      validationResults.value = setValidations({
        validations: newValidationRules,
        state: state,
        childResults: childResults,
        resultsCache: resultsCache,
        globalConfig: globalConfig,
        instance: instance ? instance.proxy : {},
        externalResults: $externalResults
      });
    }, {
      immediate: true
    });
  }

  if (instance) {
    // send all the data to the parent when the function is invoked inside setup.
    sendValidationResultsToParent(validationResults, {
      $registerAs: $registerAs,
      $scope: $scope,
      $stopPropagation: $stopPropagation
    }); // before this component is destroyed, remove all the data from the parent.

    onBeforeUnmount(function () {
      return removeValidationResultsFromParent($registerAs);
    });
  } // TODO: Change into reactive + watch


  return computed(function () {
    return Object.assign({}, unref(validationResults.value), childResults.value);
  });
}

export default useVuelidate;
export { CollectFlag, useVuelidate };
